\section{Type Extension}
All types of structures are defined in \cd{window.T}.

We pass some funtion as parameter sometimes, such as \cd{.map(fn), .forEach(fn), .sort(compare)} \ldots The default \cd{fn} for \cd{.map(fn)} is \cd{x => x}, while the default for comparasion is \cd{(x, y) => x - y}.

\subsection{Type Constructors}
\mmb{new T.LinkedList()}
Constructs a new linked list
\mmb{new T.Stack()}
Constructs a new stack
\mmb{new T.Queue()}
Constructs a new queue
\mmb{new T.MaxHeap(): heap}
Gets a new max heap
\mmb{new T.MinHeap(compare): heap}
Gets a new min heap
\mmb{new T.QuickFind(n: number): unionfind}
Gets a union find by QuickFind algorithm
\mmb{new T.WeightedQuickUnion(n: number): unionfind}
Gets a union find by Weighted QuickFind algorithm
\mmb{new T.BinarySearchTree(compare)}
Gets a Binary Search Tree with the specific comparasion rule
\mmb{new T.Graph(n: number, directed: bool = false)}
Gets a unweighted graph with \cd{n} vertex, which is undirected by default
\mmb{new T.GraphW(n: number, directed: bool = false)}
Gets a weighted graph with \cd{n} vertex, which is undirected by default

\subsection{General Members of Linear Collection}
Linear collection like \cd{LinkedList, Stack, Queue} \ldots have the default traversal order. 

\cd{LinkedList} traverses each element in \cd{0 ... n-1} order;

\cd{Stack} traverses each element in \cd{LIFO} order;

\cd{Queue} traverses each element in \cd{FIFO} order;

There are some general members defined in linear collection. 

\mmb{.size(): number}
Gets the size (length) of the linear collecion.
\mmb{.isEmpty(): boolean}
Returns \cd{true} when the linear collection is empty, otherwise \cd{false}.
\mmb{.forEach(x =\textgreater void): void}
Applies a function to each element in default order.
\mmb{.map(x =\textgreater any): [any]}
Gets a new array mapped from \cd{x => any} in default order.
\mmb{toArray(): [ ]}
Gets a new array containing each element of this linear collection in default order.

\subsection{LinkedList}
\mmb{insert(any, i): void}
Inserts an element after ith element, indexing from 0, if \cd{i >= size()}, insert elem at the end of linear collection.
%
%## Members
%<a name="linkedlist"></a>
%### LinkedList
%Call | Meaning
%:----|:-------
%`size(): number` | the size of the list
%`isEmpty(): boolean` | true when list is empty, otherwise false
%`` | 
%`` | insert elem at the end of list
%`reverse(): void` | reverse the list itself
%`remove(any): void` | remove the first node with elem, if no such node, wo do nothing
%`forEach(x => void): void` | apply the function to each element in `0..n-1` order
%`map(x => any): [any]` |  get a new array mapped from `x => any` in `0..n-1` order
%`toArray(): []` | get a new array containing each element of list in `0..n-1` order
%
%[Back to top](#t)
%
%<a name="stack"></a>
%### Stack
%Call | Meaning
%:----|:-------
%`size(): number` | the size of the list
%`isEmpty(): boolean` | true when list is empty, otherwise false
%`push(any): void` | push item into stack
%`peek(): any` | get the last item from stack, error when empty
%`pop(): any` | get the last item and remove it, error when empty
%`forEach(x => void): void` | apply the function to each element in LIFO order
%`map(x => any): [any]` |  get a new array mapped from `x => any` in LIFO order
%`toArray(): []` | get a new array containing each element of stack in LIFO order
%
%[Back to top](#t)
%
%<a name="queue"></a>
%### Queue
%Call | Meaning
%:----|:-------
%`size(): number` | the size of the list
%`isEmpty(): boolean` | true when list is empty, otherwise false
%`enqueue(any): void` | add item into queue
%`peek(): any` | get the first added item from queue, error when empty
%`dequeue(): any` | get the first added item and remove it, error when empty
%`forEach(x => void): void` | apply the function to each element in FIFO order
%`map(x => any): [any]` |  get a new array mapped from `x => any` in FIFO order
%`toArray(): []` | get a new array containing each element of queue in FIFO order
%
%[Back to top](#t)
%
%<a name="heap"></a>
%### Heap
%Usage of `Sorting.MinHeap` is same as `Sorting.MaxHeap`, except the constructor. Notice, there is a pseudo element at `heap[0]` which we might not use.
%
%The reason we do not implement public `forEach`, `map` or `toArray` is that any of these function will destroy the heap.
%
%Call | Meaning
%:----|:-------
%`isEmpty(): boolean` | returns true if there is no real element in heap
%`size(): number` | gets the number of elements in heap
%`push(any): number` | inserts a element into the heap, and gets length of the new heap
%`pop(): any` | gets the max / min element from heap, and remove it, keeping heap sorted
%
%[Back to top](#t)
%
%<a name="minheap"></a>
%### MinHeap
%Call | Meaning
%:----|:-------
%`update(` <br></a> `key: x=>boolean,` <br></a> `when: x=>boolean,` <br></a> `how: x=>void): boolean` | find the elem holding `key(x)`, if `when(x)`, then update elem by `how(x)`, return false iff no elem hoding `key(x)`
%
%[Back to top](#t)
%
%<a name="quickfind"></a>
%### QuickFind
%When we construct a quick find, we pass `n` as the capacity of the quick find. We index the elements in quick find from `0` to `n-1` (inclusive).
%
%Call | Meaning
%:----|:-------
%`connected(p, q): boolean` | returns true iff `p` is connected with `q`
%`count(): number` | gets the number of components which are not connected with each other
%`union(p, q): number` | unions `p` with `q`, and returns the count after union
%
%Different algorithms of quick find bring us different growth of the cost, see below:
%
%Type | `connected(p, q)` | `union(p, q)`
%:----|:-----------------:|:-------------
%`T.QuickFind(N)` | `O(1)` | `O(N)`
%`T.WeightedQuickFind(N)` | `O(lg N)` | `O(lg N)`
%
%[Back to top](#t)
%
%<a name="binarysearchtree"></a>
%### BinarySearchTree
%We can indicate the comparasion rule by constructor parameter which will be used for greater left instead of smaller left by default.
%
%For `search`, `insert`, `delete` operations which travel the tree, we provide you two versions, one is iterative operation, the other is recursive one whose function name is initialized with a `r`. Always choose iterative operations as a recommandation.
%
%And, here is definition for some properties of tree, according to Wikipedia:
%
%> The height of a node is the length of the longest downward path to a leaf from that node. 
%> 
%> The depth of a node is the length of the path to its root (i.e., its root path). The root node has depth zero, leaf nodes have height zero.
%> 
%> The height of the root is the height of the tree. An empty tree (tree with no nodes, if such are allowed) has depth and height `âˆ’1`.
%
%We have defined different traversal way in `T.TRAVERSAL.*`. The default traversal way is `T.TRAVERSAL.IN_ORDER`.
%
%Recursive Call | Iterative Call | Meaning
%:--------------|:---------------|:-------
%`rSearch(elem): node` | `search(elem): node` | searches elem in this tree, returns node which contains elem, or null if not exsits
%`rInsert(elem): void` | `insert(elem): void` | inserts elem under `BST` order, no duplication
%`rForEach(` <br></a> `TRAVERSAL,` <br></a> `fn): void` | `forEach(` <br></a> `TRAVERSAL,` <br></a> `fn): void` | travel this `BST` tree with specific `T.TRAVERSAL` order
%`rMap(` <br></a> `TRAVERSAL,` <br></a> `fn: x => any): [any]` | `map(` <br></a> `TRAVERSAL,` <br></a> `fn): [any]` | maps each element of this `BST` tree into an array with specific `T.TRAVERSAL` order
%
%[Back to top](#t)
%
%<a name="graph"></a>
%### Graph
%Representation of unweighted graph, and it is undirected graph by default.
%
%To build a graph, we must pass `n` as number of vertex. `n`, the number of vertex, is readonly after built graph.
%
%However, when we call `v()` or `e()` as below, the number we get is the valid number of vertex or edges, which has not been visited or marked.
%
%Call | Meaning
%:----|:-------
%`n: number` | gets the actual number of vertex, whether it is visited, marked or not
%`v(): number`| gets the number of vertex, which has not been visited
%`e(): number`| gets the number of edges, which has not been marked invalid, and the sourcing vertex has not been visited
%`clone(): Graph` | gets a new cloned graph from this graph itself
%`toString(` <br></a> `verbose: bool = false)` | gets the information of this graph, containing only number of v and e by default
%
%[Back to top](#t)
%
%<a name="graphw"></a>
%### GraphW
%The members in weighted graph is same as the graph, except some differences between the adjancency list representation:
%
%Type | Element in Adjancency List
%:----|:-------
%`T.Graph` | `[v, [u1, u2, u3, ...]]`
%`T.GraphW` | `[v, [(u1, w1), (u2, w2), (u3, w3), ...]]`
%
%[Back to top](#t)
