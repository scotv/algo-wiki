All types of structures are defined in *window.T*

=Constructors=
|| *Call* || *Meaning* ||
|| `new T.LinkedList()` || constructs a new linked list ||
|| `new T.Stack()` || constructs a new stack ||
|| `new T.Queue()` || constructs a new queue ||
|| `T.MaxHeap(): heap` || gets a new max heap, _new_ is option ||
|| `T.MinHeap(compare: fn): heap` || gets a new min heap, _new_ is option. see [APISorting Sorting docs] for `compare` which is used in Dijkstra algorithm ||
|| `new T.Graph(n: number, directed: bool = false)` || gets a unweighted graph with n vertex, which is undirected by default ||
|| `new T.GraphW(n: number, directed: bool = false)` || gets a weighted graph with n vertex, which is undirected by default ||

=Static=
|| *Call* || *Meaning* ||
|| `T.Stack.validPopSeries(pushArray, popArray): boolean` || true when we can get the pop series by the push series ||

=Members=
==`LinkedList`==
|| *Call* || *Meaning* ||
|| `size(): number` || the size of the list ||
|| `isEmpty(): boolean` || true when list is empty, otherwise false ||
|| `insert(any, i): void` || insert elem after ith element, basing 0, if i >= length, insert elem at the end of list ||
|| `push(any): void` || insert elem at the end of list ||
|| `reverse(): void` || reverse the lst itself ||
|| `remove(any): void` || remove the first node with elem, if no such node, wo do nothing ||
|| `forEach(x => void): void` || apply the function to each element in 0..n-1 order ||
|| `map(x => any): [any]` ||  get a new array mapped from `x => any` in 0..n-1 order ||
|| `toArray(): []` || get a new array containing each element of list in 0..n-1 order ||

==`Stack`==
|| *Call* || *Meaning* ||
|| `size(): number` || the size of the list ||
|| `isEmpty(): boolean` || true when list is empty, otherwise false ||
|| `push(any): void` || push item into stack ||
|| `peek(): any` || get the last item from stack, error when empty ||
|| `pop(): any` || get the last item and remove it, error when empty ||
|| `forEach(x => void): void` || apply the function to each element in LIFO order ||
|| `map(x => any): [any]` ||  get a new array mapped from `x => any` in LIFO order ||
|| `toArray(): []` || get a new array containing each element of stack in LIFO order ||

==`Queue`==
|| *Call* || *Meaning* ||
|| `size(): number` || the size of the list ||
|| `isEmpty(): boolean` || true when list is empty, otherwise false ||
|| `enqueue(any): void` || add item into queue ||
|| `peek(): any` || get the first added item from queue, error when empty ||
|| `dequeue(): any` || get the first added item and remove it, error when empty ||
|| `forEach(x => void): void` || apply the function to each element in FIFO order ||
|| `map(x => any): [any]` ||  get a new array mapped from `x => any` in FIFO order ||
|| `toArray(): []` || get a new array containing each element of queue in FIFO order ||

==`Heap`==
Usage of `Sorting.MinHeap` is same as `Sorting.MaxHeap`, except the constructor. Notice, there is a pseudo element at `heap[0]` which we might not use.

The reason we do not implement public `forEach`, `map` or `toArray` is that any of these function will destroy the heap.

|| *Call* || *Meaning* ||
|| `isEmpty(): boolean` || returns true if there is no real element in heap ||
|| `push(any): number` || inserts a element into the heap, and gets length of the new heap ||
|| `pop(): any` || gets the max / min element from heap, and remove it, keeping heap sorted ||

==`Graph`==
Representation of unweighted graph, and it is undirected graph by default.

To build a graph, we must pass `n` as number of vertex. `n`, the number of vertex, is readonly after built graph.

However, when we call `v()` or `e()` as below, the number we get is the valid number of vertex or edges, which has not been visited or marked.

|| *Call* || *Meaning* ||
|| `n: number` || gets the actual number of vertex, whether it is visited, marked or not ||
|| `v(): number`|| gets the number of vertex, which has not been visited ||
|| `e(): number`|| gets the number of edges, which has not been marked invalid, and the sourcing vertex has not been visited ||
|| `clone(): Graph` || gets a new cloned graph from this graph itself ||
|| `toString(verbose: bool = false)` || gets the information of this graph, containing only number of v and e by default ||

==`GraphW`==
The members in weighted graph is same as the graph, except some differences between the adjancency list representation:

|| *Type* || *Element in Adjancency List* ||
|| `T.Graph` || `[v, [u1, u2, u3, ...]]` ||
|| `T.Graph` || `[v, [[u1, w1], [u2, w2], [u3, w3], ...]]` ||